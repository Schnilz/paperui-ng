

<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>JSDoc: storage-webworker/store.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Muli:100,400,700|Oswald:300|Inconsolata,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">
    <link type="text/css" rel="stylesheet" href="https://jmblog.github.io/color-themes-for-google-code-prettify/themes/tomorrow-night.min.css">
    <link type="text/css" rel="stylesheet" href="styles/app.min.css">
</head>

<body>
    <div id="stickyNavbarOverlay"></div>
    <div class="top-navbar">
        <div class="container">
            <nav class="navbar" role="navigation" aria-label="main navigation">
                <div class="navbar-brand">
                     
                        <img src="assets/img/openhab-logo.svg" alt="logo">
                    
                     
                        <h1 class="navbar-item">Setup&Maintenance JS Documentation</h1>
                    
                    <a id="hamburger" role="button" class="navbar-burger" aria-label="menu" aria-expanded="false">
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                        <span aria-hidden="true"></span>
                    </a>
                </div>
                 
                <div class="navbar-menu">
                    <div class="navbar-end">
                    
                        <div class="navbar-item">
                            <a href="https://github.com/davidgraeff/paperui-ng" target="_blank">Github</a>
                        </div>
                    
                        <div class="navbar-item">
                            <a href="https://davidgraeff.github.io/paperui-ng/" target="_blank">The application</a>
                        </div>
                    
                    </div>
                </div>
                
            </nav>
        </div>
    </div>
    <div class="container">
        <div class="columns">
            <div class="column is-3" id="sidebarNav">
                <div class="sidebar">
                    <nav>
                        <h2><a href="index.html">Home</a></h2><div class="category"><h3><a href="global.html">Global</a></h3></div><div class="category"><h2>App</h2><h3>Modules</h3><ul><li><a href="module-app.html">app</a></li></ul><h3>Classes</h3><ul><li><a href="module-app.exports.StorageConnector.html">exports.StorageConnector</a></li></ul></div><div class="category"><h2>Data Components</h2><h3>Modules</h3><ul><li><a href="module-ohcomponents.html">ohcomponents</a></li></ul><h3>Externals</h3><ul><li><a href="oh-change-filter.html">oh-change-filter</a></li><li><a href="oh-doc-link.html">oh-doc-link</a></li><li><a href="oh-dropdown-bind.html">oh-dropdown-bind</a></li><li><a href="oh-event-bind.html">oh-event-bind</a></li><li><a href="oh-form-bind.html">oh-form-bind</a></li><li><a href="oh-list-bind.html">oh-list-bind</a></li><li><a href="oh-login-status-link.html">oh-login-status-link</a></li><li><a href="oh-nav-auto-link.html">oh-nav-auto-link</a></li><li><a href="oh-prop-bind.html">oh-prop-bind</a></li><li><a href="oh-script-snippets.html">oh-script-snippets</a></li><li><a href="oh-tutorial-starter.html">oh-tutorial-starter</a></li><li><a href="oh-vue-bind.html">oh-vue-bind</a></li><li><a href="oh-websocket-data.html">oh-websocket-data</a></li></ul><h3>Classes</h3><ul><li><a href="UpdateAdapter.html">UpdateAdapter</a></li></ul><h3>Events</h3><ul><li><a href="oh-websocket-data.html#event:data">data</a></li></ul></div><div class="category"><h2>Rules</h2><h3>Modules</h3><ul><li><a href="module-rule.html">rule</a></li></ul><h3>Classes</h3><ul><li><a href="module-rule.ImportExport.html">ImportExport</a></li><li><a href="module-rule.LayoutManager.html">LayoutManager</a></li><li><a href="module-rule.OHCaptionComponent.html">OHCaptionComponent</a></li><li><a href="module-rule.OHRuleComponent.html">OHRuleComponent</a></li></ul></div><div class="category"><h2>Webworker Storage Model</h2><h3>Modules</h3><ul><li><a href="module-storage-webworker.html">storage-webworker</a></li></ul><h3>Classes</h3><ul><li><a href="module-storage-webworker.StateWhileRevalidateStore.html">StateWhileRevalidateStore</a></li><li><a href="module-storage-webworker-StorageWorker.html">StorageWorker</a></li></ul></div><div class="category"><h2>Tutorial</h2><h3>Modules</h3><ul><li><a href="module-tutorial.html">tutorial</a></li></ul><h3>Namespaces</h3><ul><li><a href="module-tutorial.Tools.html">Tools</a></li></ul></div><div class="category"><h2>Web Components</h2><h3>Modules</h3><ul><li><a href="module-ui-cron-expression.html">ui-cron-expression</a></li><li><a href="module-ui-maps.html">ui-maps</a></li><li><a href="module-ui-time-graph.html">ui-time-graph</a></li><li><a href="module-ui-time-picker.html">ui-time-picker</a></li><li><a href="module-uicomponents.html">uicomponents</a></li></ul><h3>Externals</h3><ul><li><a href="nav-ajax-page-load.html">nav-ajax-page-load</a></li><li><a href="nav-breadcrumb.html">nav-breadcrumb</a></li><li><a href="nav-buttons.html">nav-buttons</a></li><li><a href="oh-rule-editor.html">oh-rule-editor</a></li><li><a href="ui-changelog.html">ui-changelog</a></li><li><a href="ui-codeeditor.html">ui-codeeditor</a></li><li><a href="ui-community-topics.html">ui-community-topics</a></li><li><a href="ui-context-help.html">ui-context-help</a></li><li><a href="ui-cron-expression.html">ui-cron-expression</a></li><li><a href="ui-drop-zone.html">ui-drop-zone</a></li><li><a href="ui-dropdown.html">ui-dropdown</a></li><li><a href="ui-filter.html">ui-filter</a></li><li><a href="ui-github-issues.html">ui-github-issues</a></li><li><a href="ui-maps.html">ui-maps</a></li><li><a href="ui-multiselect.html">ui-multiselect</a></li><li><a href="ui-notification.html">ui-notification</a></li><li><a href="ui-switch.html">ui-switch</a></li><li><a href="ui-tabs.html">ui-tabs</a></li><li><a href="ui-tags.html">ui-tags</a></li><li><a href="ui-time-graph.html">ui-time-graph</a></li><li><a href="ui-time-picker.html">ui-time-picker</a></li><li><a href="ui-youtube.html">ui-youtube</a></li></ul><h3>Events</h3><ul><li><a href="ui-tags.html#event:input">input</a></li></ul></div><div class="category"><h2>Web Components (Reactive)</h2><h3>Modules</h3><ul><li><a href="module-vue.html">vue</a></li></ul><h3>Externals</h3><ul><li><a href="oh-vue.html">oh-vue</a></li><li><a href="oh-vue-form.html">oh-vue-form</a></li><li><a href="oh-vue-list.html">oh-vue-list</a></li></ul></div>
                    </nav>
                </div>
            </div>
            <div class="column is-9-desktop">
                <div class="content" id="main-content-wrapper">
                    <header class="page-title">
                        <p>Source</p>
                        <h1>storage-webworker/store.js</h1>
                    </header>
                    
                    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { openDb } from 'idb';

import { fetchWithTimeout, FetchError } from '../_common/fetch';
import { CompareTwoDataSets } from '../_common/compareTwoDatasets';

import { hack_addNotYetSupportedStoreData, blockLiveDataFromTables } from './addNotYetSupportedStoreData';
import { hack_rewriteEntryToNotYetSupportedStoreLayout, hack_rewriteTableToNotYetSupportedStoreLayout, blockLiveDataFromTableRows } from './rewriteToNotYetSupportedStoreLayout';
import { tables, tableIDtoEntry, dbversion } from './openhabStoreLayout';

/**
 * This is the frontends backend storage / cache for the OH REST interface. It is implemented
 * in a state-while-revalidate strategy, so for each get/getAll we first return what we have
 * in the database and perform a REST request as well. The REST response is inserted into the
 * database asynchronously at receive time and if any changes are detected, those are
 * propagated via events.
 * 
 * A connection to the Server-Send-Events endpoint is also established (/rest/events). Received
 * changes are also inserted into the database and propagated via events.
 * 
 * ## Events
 * 
 * The following events are dispatched:
 * 
 * - "connectionEstablished"
 * - "connectionLost"
 * - "storeItemChanged" (Event details: value, storename)
 * - "storeItemAdded" (Event details: value, storename)
 * - "storeItemRemoved" (Event details: value, storename)
 * - "storeChanged" (Event details: value, storename)
 * 
 * ## Sorting / Filtering
 * 
 * Sorting / Filtering / Limiting is not performed in here, because indexed DB does not provide
 * those features. Those operations are performed on a full getAll() data set. Find it performed in "index.js".
 * 
 * ## Change detection / Diffing
 * 
 * If we first return a cached list of items in `getAll` and soon after notify about the received list of items
 * we cause double work for the Views. To implement the state-while-revalidate strategy in a more optimal
 * way, we perform a change-detection between the received list of items and the stored one.
 * 
 * A received REST response might have json properties stored in a different order than what we have
 * in the database. A naive object comparision will always find the cache and REST response to be different.
 * 
 * Therefore received data and cached data are diff'ed by hand, see `CompareTwoDataSets`.
 * That way we can tell the view exactly which item in a list of items has changed.
 * 
 * In average that leads to a fast retrival of data on a `get` and `getAll` call and one or
 * two notifications afterwards about a changed single item in the potentially huge list.
 * 
 * **TODO:** This store class contains the indexedDB interface ("get","getAll") code as well
 * as http database refresh code ("performRESTandNotify" etc). To honour separation of
 * concerns this should be split into those two parts.
 * 
 * @category Webworker Storage Model
 * @memberof module:storage-webworker
 */
class StateWhileRevalidateStore extends EventTarget {
  constructor() {
    super();
    this.activeRESTrequests = {};
    this.connected = false;
    this.throttleTimeMS = 2000; // Don't request the same REST url again for this throttle time
    this.expireDurationMS = 1000 * 60 * 60; // 1 hour cache for `getAll`
    this.lastRefresh = {}; // Will contain entries like url:time where time is Date.now()-like.
  }

  /**
   * Closes the database connection and the server-send-event connection for updates.
   */
  dispose() {
    this.activeRESTrequests = {};
    if (this.evtSource) { this.evtSource.onerror = null; this.evtSource.onmessage = null; this.evtSource.close(); }
    if (this.db) {
      db.close();
      delete this.db;
    };
  }

  /**
   * Waits for the database to be ready, refreshes some REST endpoints and starts Server-Send-Events
   * Start Server Send Events.
   * 
   * @param {String} host The host to connect to
   * @returns {Promise} Return a promise that resolves to true on a successful connection and an Error otherwise.
   */
  async reconnect(host) {
    if (this.host != host) {
      await this.connectToDatabase(host);
      await this.removeTutorialData().catch(e => console.error("Remove tutorial data failed", e));
      this.host = host;
    }

    this.activeRESTrequests = {};

    if (this.evtSource) { this.evtSource.onerror = null; this.evtSource.onmessage = null; this.evtSource.close(); }

    if (this.host == "demo") {
      return fetchWithTimeout("../dummydata/demodata.json")
        .then(response => response.json())
        .then(async json => {
          const stores = Object.keys(json);
          for (let storename of stores) {
            try {
              await this.initialStoreFill(storename, json[storename], false);
            } catch (e) {
              console.warn("Failed to restore demo table", storename, e);
            }
          }
          this.connected = true;
          this.dispatchEvent(new CustomEvent("connectionEstablished", { detail: this.host }));
          return true;
        }).catch(e => {
          this.connected = false;
          this.dispatchEvent(new CustomEvent("connectionLost", { detail: { type: 404, message: e.toString() } }));
          throw e;
        });
    }

    // Fetch all endpoints in parallel, replace the stores with the received data
    const requests = tables
      .filter(item => item.onstart)
      .map(item => fetchWithTimeout(this.host + "/" + item.uri)
        .catch(e => { console.warn("Failed to fetch", this.host + "/" + item.uri); throw e; })
        .then(response => response.json())
        .then(json => this.initialStoreFill(item.id, json, true))
        .catch(e => { console.warn("Failed to fill", item.id); throw e; })
      );

    // Wait for all promises to complete and start server-send-events
    return Promise.all(requests).then(() => {
      this.evtSource = new EventSource(this.host + "/rest/events");
      this.evtSource.onmessage = this.sseMessageReceived.bind(this);
      this.evtSource.onerror = this.sseMessageError.bind(this);
    }).then(() => {
      this.dispatchEvent(new CustomEvent("connectionEstablished", { detail: this.host }));
      this.connected = true;
      return true;
    }).catch(e => {
      this.connected = false;
      const message = e.toString();
      let type = 404;
      if (message.includes("TypeError") &amp;&amp; !message.includes("Failed to fetch")) {
        type = 4041; // custom error code for Cross-orgin access
      }
      this.dispatchEvent(new CustomEvent("connectionLost", { detail: { type, message } }));
      throw e;
    });
  }
  /**
   * First retrieve fresh data for all tables, then dump the entire indexeddb.
   * @returns {Object} Returns an object containing all database entries.
   */
  async dump() {
    if (this.dumpRunning) return;
    let dumpobject = {};
    this.dispatchEvent(new CustomEvent("dump", { detail: { progress: 0 } }));

    try {
      this.dumpRunning = true;
      const requests = tables.filter(item => item.uri !== undefined &amp;&amp; !item.urlsuffix);
      let counter = 0;
      for (let item of requests) {
        await this.getAll(item.id, { force: true });
        ++counter;
        this.dispatchEvent(new CustomEvent("dump", { detail: { progress: Math.floor(counter * 80 / requests.length) } }));
      }

      let thingTypes = await this.getAll("thing-types", { force: true });
      for (let thingType of thingTypes) {
        await this.get("thing-types-extended", thingType.UID, { force: true });
      }
      this.dispatchEvent(new CustomEvent("dump", { detail: { progress: 90 } }));

      let bindings = await this.getAll("bindings", { force: true });
      for (let binding of bindings) {
        await this.get("binding-config", binding.id, { force: true });
      }
      this.dispatchEvent(new CustomEvent("dump", { detail: { progress: 91 } }));

      let services = await this.getAll("services", { force: true });
      for (let service of services) {
        await this.get("service-config", service.id, { force: true });
      }

      this.dispatchEvent(new CustomEvent("dump", { detail: { progress: 92 } }));

      const stores = tables.map(e => e.id);
      const tx = this.db.transaction(stores, 'readonly');
      counter = 0;
      for (let store of stores) {
        dumpobject[store] = await tx.objectStore(store).getAll();
        ++counter;
        this.dispatchEvent(new CustomEvent("dump", { detail: { progress: 92 + Math.floor(counter * 8 / stores.length) } }));
      }
      this.dispatchEvent(new CustomEvent("dump", { detail: { progress: 100, done: true } }));
    } catch (e) {
      this.dispatchEvent(new CustomEvent("dump", { detail: { done: true, error: e } }));
      console.warn("Dump incomplete!", e);
    } finally {
      this.dumpRunning = false;
    }
    return dumpobject;
  }

  /**
   * Configures the database
   * 
   * @param {Number} expireDurationMS The cache expire time in milliseconds
   * @param {Number} throttleTimeMS The throttle time in milliseconds
   */
  async configure(expireDurationMS, throttleTimeMS) {
    this.throttleTimeMS = throttleTimeMS;
    this.expireDurationMS = expireDurationMS;
    return true;
  }

  convertToMap(tableLayout, options, values) {
    if (options.asmap === true) {
      const KEY = tableLayout.key;
      return values.then(arraydata => arraydata.reduce((a, v) => (a[v[KEY]] = v, a), {}))
    } else if (options.asmap) {
      const KEY = options.asmap;
      return values.then(arraydata => arraydata.reduce((a, v) => {
        const INDEX = v[KEY];
        if (!a[INDEX]) a[INDEX] = [];
        a[INDEX].push(v);
        return a;
      }, {}))
    }

    return values;
  }

  /**
   * Request an array of items from a table (rest endpoint).
   * This method will first return what is found in the cache
   * (if the cache is still valid) and then also perform
   * a REST request for fresh data.
   * 
   * @param {String} storename The table name
   * @param {Object} options Options
   * @param {Boolean} options.force If the cache has no data, wait for
   *  HTTP received data
   * @param {Boolean} options.asmap Returns a map instead of an array,
   *  mapping from the index key to the entry
   */
  async getAll(storename, options) {
    const tableLayout = tableIDtoEntry[storename];
    if (tableLayout.virtual) { // virtual tables support
      return this.convertToMap(tableLayout, options, tableLayout.virtual(this, options));
    }

    const tx = this.db.transaction(storename, 'readonly');
    let val = tx.objectStore(storename).getAll();

    val = this.convertToMap(tableLayout, options, val);

    try {
      await tx.complete
    } catch (e) {
      console.warn("Failed to read", storename, objectid)
      val = null;
    };

    if (this.blockRESTrequest(storename))
      return val;

    const uri = tableLayout.uri;
    if (!uri) {
      console.warn("No URI for", storename);
      throw new Error("No URI for " + storename);
    }

    if (this.cacheStillValid(uri)) {
      return val;
    }

    // Return cached value but also request a new value
    let newVal = this.performRESTandNotify(uri)
      .catch(e => { console.warn("Failed to fetch", uri); throw e; })
      .then(json => { if (!Array.isArray(json)) throw new Error("Returned value is not an array"); return json; })
      .then(json => this.replaceStore(storename, json))

    newVal = this.convertToMap(tableLayout, options, newVal);
    if (options.force) { // forced: if no cached OR empty cache value, return http promise
      if (!val || val.length == 0) return newVal;
    }
    return val || newVal; // If no cached value return http promise
  }

  /**
   * Request a single item from a table (rest endpoint).
   * This method will first return what is found in the cache
   * (if the cache is still valid) and then also perform
   * a REST request for fresh data.
   * 
   * Some tables do not have an index key or a REST endpoint
   * for requesting a single item. The entire table is fetched
   * then and filtered afterwards.
   * 
   * @param {String} storename The table name
   * @param {String} objectid The object id
   * @param {Object} options Options
   * @param {Boolean} options.force If the cache has no data, wait for
   *  HTTP received data
   */
  async get(storename, objectid, options) {
    if (!objectid) throw new Error("No object id set for " + storename);
    const tableLayout = tableIDtoEntry[storename];
    if (tableLayout.virtual) { // virtual tables support
      return tableLayout.virtual(this, options, objectid);
    }

    const tx = this.db.transaction(storename, 'readonly');
    let val = tx.objectStore(storename).get(objectid);


    val = unwrapIfRequired(tableLayout, val);

    try {
      await tx.complete
    } catch (e) {
      console.warn("Failed to read", storename, objectid)
      val = null;
    };

    if (this.blockRESTrequest(storename, objectid))
      return val;

    let uri = tableLayout.uri;
    if (!uri) {
      console.warn("No URI for", storename);
      throw new Error("No URI for " + storename);
    }

    if (tableLayout.singleRequests !== false) {
      uri += "/" + objectid;
    }

    if (tableLayout.urlsuffix) {
      uri += tableLayout.urlsuffix;
    }

    if (this.cacheStillValid(uri)) {
      return val;
    }

    // Return cached value but also request a new value. If cached==null return only new value
    let newVal = this.performRESTandNotify(uri, false)
      .catch(e => { console.warn("Fetch failed for", uri); throw e; })
      .then(json => tableLayout.singleRequests === false ? extractFromArray(storename, objectid, json) : json)
      .then(json => this.insertIntoStore(storename, wrapIfRequired(tableLayout, objectid, json)))
      .then(json => unwrapIfRequired(tableLayout, json));

    if (options.force) { // forced: if no cached OR empty cache value, return http promise
      if (!val || val[tableLayout.key] != objectid) return newVal;
    }
    return val || newVal; // If no cached value return http promise
  }

  injectTutorialData(storename, objectdata) {
    this.lastRefresh[tableIDtoEntry[storename].uri] = "block";
    this.insertIntoStore(storename, objectdata);
  }

  async removeTutorialData() {
    await ignoreNotFound(this.removeFromStore("bindings", { "id": "demo1" }));
    await ignoreNotFound(this.removeFromStore("inbox", { "thingUID": "demo1:demo1" }));
    await ignoreNotFound(this.removeFromStore("discovery", { "id": "demo1" }));
    await ignoreNotFound(this.removeFromStore("things", { "UID": "demo1" }));
    await ignoreNotFound(this.removeFromStore("thing-types", { "UID": "demo1" }));
    await ignoreNotFound(this.removeFromStore("rules", { "uid": "demo1" }));
    await ignoreNotFound(this.removeFromStore("rules", { "uid": "demo2" }));
    await ignoreNotFound(this.removeFromStore("items", { "name": "demo1" }));
    await ignoreNotFound(this.removeFromStore("items", { "name": "demo2" }));
    delete this.lastRefresh[tableIDtoEntry["bindings"].uri];
    delete this.lastRefresh[tableIDtoEntry["inbox"].uri];
    delete this.lastRefresh[tableIDtoEntry["discovery"].uri];
    delete this.lastRefresh[tableIDtoEntry["things"].uri];
    delete this.lastRefresh[tableIDtoEntry["rules"].uri];
    delete this.lastRefresh[tableIDtoEntry["items"].uri];
    delete this.lastRefresh[tableIDtoEntry["thing-types"].uri];
  }

  sseMessageReceived(e) {
    const data = JSON.parse(e.data);
    if (!data || !data.payload || !data.type || !data.topic) {
      console.warn("SSE has unknown format", data.type, data.topic, data.payload);
      return;
    }
    const topic = data.topic.split("/");
    const storename = topic[1];
    let newState;
    console.debug("SSE", data);
    switch (data.type) {
      // -- Added --
      case "ItemAddedEvent":
      case "RuleAddedEvent":
      case "InboxAddedEvent":
      case "ThingAddedEvent":
        newState = JSON.parse(data.payload);
        this.insertIntoStore(storename, newState);
        return;
      // -- Updated --
      case "InboxUpdatedEvent":
        newState = JSON.parse(data.payload);
        this.insertIntoStore(storename, newState);
        return;
      case "ItemUpdatedEvent":
      case "RuleUpdatedEvent":
      case "ThingUpdatedEvent":
        newState = JSON.parse(data.payload)[0];
        this.insertIntoStore(storename, newState);
        return;
      // -- Removed --
      case "ItemRemovedEvent":
      case "RuleRemovedEvent":
      case "InboxRemovedEvent":
      case "ThingRemovedEvent":
        this.removeFromStore(storename, JSON.parse(data.payload));
        return;
      // -- State info changed --
      case "ItemStateEvent":
        newState = JSON.parse(data.payload);
        this.changeItemState(storename, topic[2], newState.value, "state");
        return;
      case "RuleStatusInfoEvent":
        newState = JSON.parse(data.payload);
        this.changeItemState(storename, topic[2], newState, "status");
        return;
      case "ThingStatusInfoEvent":
        newState = JSON.parse(data.payload);
        this.changeItemState(storename, topic[2], newState, "statusInfo");
        return;
      // -- Ignored events
      case "ThingStatusInfoChangedEvent":
      case "ItemStateChangedEvent":
      case "ItemStatePredicatedEvent":
      case "ItemCommandEvent":
        return;
    }
    console.warn("Unhandled SSE", data);
  }

  sseMessageError(e) {
    // The server-send-event part of openHAB is crap unfortunately and we will receive a lot
    // of disconnections. For OH3 websockets would be awesome, I guess.
    //console.log("sse error", e);
  }

  async connectToDatabase(hostname) {
    if (this.db) {
      this.db.close();
      delete this.db;
    }

    let hasPerformedUpdate = false;
    this.db = await openDb(hostname, dbversion, db => {
      console.log("Upgrading database to version", dbversion);
      hasPerformedUpdate = true;
      const objs = db.objectStoreNames;
      for (let ojs of objs) {
        db.deleteObjectStore(ojs);
      }
      for (let table of tables) {
        if (table.key) db.createObjectStore(table.id, { keyPath: table.key });
        else db.createObjectStore(table.id, { autoIncrement: true });
      }
    }).then(async db => {
      if (hasPerformedUpdate) await hack_addNotYetSupportedStoreData(db);
      return db;
    });
    return this.db;
  }

  /**
   * Returns true if a http request for a specific store should be blocked.
   * Useful for stores that have no direct REST endpoints like design study
   * invented ones.
   * 
   * This method always returns true if `host` is "demo".
   * 
   * @param {String} storename The store name
   */
  blockRESTrequest(storename, objectid = null) {
    if (this.host == "demo") return true;
    if (blockLiveDataFromTables.includes(storename)) return true;
    const tableRows = blockLiveDataFromTableRows[storename];
    if (tableRows &amp;&amp; tableRows[objectid]) return true;
    return false;
  }

  performRESTandNotify(uri, disconnectIfFail = true) {
    const alreadyRunning = this.activeRESTrequests[uri];
    if (alreadyRunning) return alreadyRunning;
    return this.activeRESTrequests[uri] = fetchWithTimeout(this.host + "/" + uri)
      .then(response => {
        console.debug("Got new value", this.host + "/" + uri);
        if (!this.connected) {
          this.dispatchEvent(new CustomEvent("connectionEstablished", { detail: this.host }));
          this.connected = true;
        }
        delete this.activeRESTrequests[uri];
        this.lastRefresh[uri] = Date.now();
        return response;
      })
      .then(response => response.json())
      .catch(e => {
        if (!(e instanceof FetchError) &amp;&amp; !disconnectIfFail &amp;&amp; this.connected) {
          this.connected = false;
          const message = e.toString();
          let type = 404;
          if (message.includes("TypeError") &amp;&amp; !message.includes("Failed to fetch")) {
            type = 4041; // custom error code for Cross-orgin access
          }
          console.warn("REST access failed", uri, e);
          this.dispatchEvent(new CustomEvent("connectionLost", { detail: { type, message } }));
        }
        throw e;
      });
  }

  cacheStillValid(uri) {
    const d = this.lastRefresh[uri];
    if (d === "block") {
      console.log("Tutorial blocked updates", uri);
      return true;
    }
    const r = (!!d &amp;&amp; (d + this.expireDurationMS > Date.now()));
    if (r) console.log("Cache only response for", uri);
    return r;
  }

  async initialStoreFill(storename, jsonList, requireRewrite) {
    const tx = this.db.transaction(storename, 'readwrite');
    const store = tx.objectStore(storename);
    try {
      await store.clear();
    } catch (e) {
      console.warn("Failed to clear", storename)
      throw e;
    }
    for (let entry of jsonList) {
      if (requireRewrite) entry = hack_rewriteEntryToNotYetSupportedStoreLayout(storename, entry);
      try {
        await store.add(entry);
      } catch (e) {
        console.warn("Failed to add to", storename, entry)
        throw e;
      }
    }
    await tx.complete.catch(e => {
      console.warn("Failed to initialStoreFill", storename);
      throw e;
    });
  }

  async replaceStore(storename, jsonList) {
    jsonList = await hack_rewriteTableToNotYetSupportedStoreLayout(storename, jsonList, this);
    try {
      const tx = this.db.transaction(storename, 'readwrite');
      const store = tx.objectStore(storename);
      const key_id = tableIDtoEntry[storename].key;
      const oldData = await store.getAll();
      const compare = oldData.length == jsonList.length ? new CompareTwoDataSets(key_id, oldData) : { ok: false };
      // Clear and add entry per entry
      await store.clear();
      for (let entry of jsonList) {
        await store.add(hack_rewriteEntryToNotYetSupportedStoreLayout(storename, entry));
        if (compare.ok) compare.compareNewAndOld(entry, storename);
      }
      if (compare.ok) {
        if (compare.listOfUnequal.length == 0) console.debug("No data changed");
        for (let value of compare.listOfUnequal) {
          this.dispatchEvent(new CustomEvent("storeItemChanged", { detail: { value, storename } }));
        }
      }

      // Refetch the data set to have the list in the same order as before for making it easier for
      // Vue to match existing DOM nodes. Maybe it doesn't matter.. Has to be decided.
      let value = await this.db.transaction(storename, 'readonly').objectStore(storename).getAll();
      if (!compare.ok) {
        this.dispatchEvent(new CustomEvent("storeChanged", { detail: { storename } }));
      }
      return value;
    } catch (e) {
      console.warn("Failed to replaceStore", storename);
      throw e;
    };
  }

  async removeFromStore(storename, jsonEntry) {
    if (!jsonEntry || typeof jsonEntry !== 'object' || jsonEntry.constructor !== Object) {
      console.warn("insertIntoStore must be called with an object", jsonEntry);
      return;
    }
    const tx = this.db.transaction(storename, 'readwrite');
    const store = tx.objectStore(storename);
    const id_key = tableIDtoEntry[storename].key;
    const id = jsonEntry[id_key];
    store.delete(id);

    await tx.complete.catch(e => {
      if (e instanceof DOMException &amp;&amp; e.name === "NotFoundError") {
        // Ignore NotFoundError
      } else throw (e);
    });
    this.dispatchEvent(new CustomEvent("storeItemRemoved", { detail: { "value": jsonEntry, "storename": storename } }));
    return null;
  }

  async changeItemState(storename, itemid, value, fieldname) {
    try {
      const tx = this.db.transaction(storename, 'readwrite');
      const store = tx.objectStore(storename);
      let item = await store.get(itemid);
      if (!item) {
        console.info("changeItemState: Item does not exist", itemid);
        return;
      }
      item[fieldname] = value;
      await store.put(item);
      this.dispatchEvent(new CustomEvent("storeItemChanged", { detail: { "value": item, "storename": storename } }));
    } catch (e) {
      console.warn("Failed to changeItemState", storename);
      throw e;
    };
  }

  async insertIntoStore(storename, jsonEntry) {
    if (!jsonEntry || typeof jsonEntry !== 'object' || jsonEntry.constructor !== Object) {
      console.warn("insertIntoStore must be called with an object", storename, jsonEntry);
      return;
    }
    jsonEntry = hack_rewriteEntryToNotYetSupportedStoreLayout(storename, jsonEntry);
    try {
      const tx = this.db.transaction(storename, 'readwrite');
      const store = tx.objectStore(storename);
      const id_key = tableIDtoEntry[storename].key;
      const old = await store.get(jsonEntry[id_key]);
      await store.put(jsonEntry);
      if (!old) {
        this.dispatchEvent(new CustomEvent("storeItemAdded", { detail: { "value": jsonEntry, "storename": storename } }));
      } else if (JSON.stringify(old) != JSON.stringify(jsonEntry)) {
        this.dispatchEvent(new CustomEvent("storeItemChanged", { detail: { "value": jsonEntry, "storename": storename } }));
      }
      return jsonEntry;
    } catch (e) {
      console.warn("Failed to insertIntoStore", storename);
      throw e;
    };
  }
}

export { StateWhileRevalidateStore };

function wrapIfRequired(tableLayout, objectid, json) {
  if (tableLayout.wrapkey) {
    let r = { id: objectid };
    r[tableLayout.wrapkey] = json;
    console.log("wrapIfRequired", json, r);
    return r;
  }
  return json;
}

function unwrapIfRequired(tableLayout, json) {
  if (json &amp;&amp; tableLayout.wrapkey &amp;&amp; json.id) {
    return json[tableLayout.wrapkey];
  }
  return json;
}

function extractFromArray(storename, objectid, json) {
  if (!Array.isArray(json)) return json;

  const id_key = tableIDtoEntry[storename].key;
  if (!id_key) {
    console.warn("No ID known for", storename);
    throw new Error("No ID known for " + storename);
  }

  for (let item of json) {
    if (item[id_key] == objectid) {
      return item;
    }
  }
  console.warn("Returned value is an array. Couldn't extract single value", json, uri, objectid, id_key)
  throw new Error("Returned value is an array. Couldn't extract single value");
}

function ignoreNotFound(promise) {
  return promise.catch(e => {
    if (e instanceof DOMException &amp;&amp; e.name === "NotFoundError") return; throw (e);
  });
}
</code></pre>
        </article>
    </section>




                </div>
            </div>
        </div>
    </div>

<footer class="footer">
    <div class="content has-text-centered">
        <p>Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Apr 16 2019 18:12:34 GMT+0000 (Coordinated Universal Time)</p>
        <p class="sidebar-created-by">
            <a href="https://github.com/SoftwareBrothers/better-docs" target="_blank">BetterDocs theme</a> provided with <i class="fas fa-heart"></i> by 
            <a href="http://softwarebrothers.co" target="_blank">SoftwareBrothers</a>
        </p>
    </div>
</footer>

<script> prettyPrint(); </script>
<script src="scripts/app.min.js"></script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
