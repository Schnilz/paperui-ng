import { store, createNotification } from '../app.js'; // Pre-bundled, external reference
import { tables } from '../storage-webworker/openhabStoreLayout';

class ModelAdapter {
  constructor() {
    this.STORE_ITEM_INDEX_PROP = Object.freeze("id");
    this.runtimeKeys = []; this.items = []; this.itemlist = [];
  }
  stores() { return { "user-roles": "items" } };
  getall(options = null) {
    return store.get("items", null, { force: true })
      .then(json => this.itemlist = json)
      .then(() => this.get(null, null, options));
  }
  async get(table = null, objectid = null, options = null) {
    this.items = await store.get("user-roles", null, options);
  }
  dispose() {
  }
}

const schema = {
  uri: 'http://openhab.org/schema/userrole-schema.json',
  fileMatch: ["http://openhab.org/schema/userrole-schema.json"],
  schema: {
    type: 'array',
    items: { "$ref": "#/definitions/item" },
    definitions: {
      item: {
        type: "object",
        description: "openHAB User Role",
        required: ["id", "label", "passwordhash"],
        properties: {
          id: { type: "string", description: "A unique ID for this user role", minLength: 2 },
          label: { type: "string", description: "A friendly name", minLength: 2 },
          annotation: { type: "string", description: "Your personal comment for this object" },
          description: { type: "string", description: "A user description" },
          password: { type: "string", description: "A password that will be converted to a password hash by openHAB" },
          passwordhash: { type: "string", description: "A password hash, generated by openHAB after a password has been transmitted" },
          tags: { type: "array", "uniqueItems": true, description: "Tags of this item" },
          items: { type: "array", "uniqueItems": true, description: "Items that this user role can access or nothing to not allow further specific items." },
          restEndpoints: { type: "array", description: "A list of allowed REST endpoint or nothing to allow access to everything" },
        }
      }
    }
  },
}

const ListMixin = {
  methods: {
    save: function () {
      this.message = null;
      this.messagetitle = "Saving...";
      this.inProgress = true;
      this.changed = false;
      setTimeout(() => this.inProgress = false, 1000);
    },
    remove: function () {
      if (this.item.id == "admin") {
        createNotification(null, `You are ... weird. You can't remove the administrator.`, false, 3000);
        return;
      }
      this.message = null;
      this.messagetitle = "Removing...";
      this.inProgress = true;
    },
  }
}

const ItemListMixin = {
  mounted() {
    this.modelschema = Object.freeze(schema);
  },
  methods: {
    saveAll: function (items) {
      //TODO
      console.log("save all", items);
    },
  },
  computed: {
    restEndpoints() {
      return tables.filter(e => e.label);
    }
  }
};

const mixins = [ListMixin];
const listmixins = [ItemListMixin];

export { mixins, listmixins, ModelAdapter };
